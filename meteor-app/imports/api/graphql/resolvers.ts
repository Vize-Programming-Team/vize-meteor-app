/* eslint-disable no-unused-vars */
import { GraphQLResolveInfo } from "graphql";
import { GraphQLDateTime } from "graphql-iso-date";

import * as dataModel from "imports/api/models";

// This file is generated by graphqlgen. If this file is not found or it is
// causing errors then it may not exist yet or it may be out of date. Try
// generating it with the command `./run.sh i`. (If you are working with this
// code a lot, you may prefer to use `cd meteor-app && npm run gen` instead.
// This command runs faster and ONLY generates the "./graphqlgen.js" file.)
import {
	Resolvers,
	CommentResolvers,
	CompanyResolvers,
	JobAdResolvers,
	ReviewResolvers,
	SalaryResolvers,
	UserResolvers,
	VoteResolvers,
	LocationResolvers,
	StarRatingsResolvers,
} from "./graphqlgen";

export type Context = {
	user: dataModel.User;
};

const defaultPageSize = 100;

const resolvers: Resolvers = {
	Query: {
		say: (_obj, _args, _context, _info) => "Hello world.",

		currentUser: (_obj, _args, context, _info) =>
			// The current user is added to the context
			// by the `meteor/apollo` package.
			context.user,

		allComments: (_obj, args, _context, _info) =>
			dataModel.getAllComments(
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		allCompanies: (_obj, args, _context, _info) =>
			dataModel.getAllCompanies(
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		allJobAds: (_obj, args, _context, _info) =>
			dataModel.getAllJobAds(
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		allReviews: (_obj, args, _context, _info) =>
			dataModel.getAllReviews(
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		allSalaries: (_obj, args, _context, _info) =>
			dataModel.getAllSalaries(
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		allUsers: (_obj, args, _context, _info) =>
			dataModel.getAllUsers(
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		allVotes: (_obj, args, _context, _info) =>
			dataModel.getAllVotes(
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		comment: (_obj, args, _context, _info) =>
			dataModel.getCommentById(dataModel.stringToCommentId(args.id)),

		company: (_obj, args, _context, _info) =>
			dataModel.getCompanyById(dataModel.stringToCompanyId(args.id)),

		jobAd: (_obj, args, _context, _info) =>
			dataModel.getJobAdById(dataModel.stringToJobAdId(args.id)),

		review: (_obj, args, _context, _info) =>
			dataModel.getReviewById(dataModel.stringToReviewId(args.id)),

		salary: (_obj, args, _context, _info) =>
			dataModel.getSalaryById(dataModel.stringToSalaryId(args.id)),

		user: (_obj, args, _context, _info) =>
			dataModel.getUserById(dataModel.stringToUserId(args.id)),

		vote: (_obj, args, _context, _info) =>
			dataModel.getVoteById(dataModel.stringToVoteId(args.id)),

		searchCompanies: (_obj, args, _context, _info) =>
			dataModel.searchForCompanies(
				args.searchText || "",
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		wroteAReview: (_obj, _args, context, _info) =>
			dataModel.wroteAReviewStatus(context.user),
	},

	Mutation: {
		claimWroteAReview: (_obj, args, context, _info) =>
			dataModel.claimWroteAReview(
				context.user,
				args.phoneNumber,
				args.paymentMethod
			),
	},

	CommentParent: {
		// WARNING: Comments have not been fully implemented yet. The code for
		// them is a half done mess. Keep that in mind when working with it.
		__resolveType(
			obj: dataModel.CommentParent,
			_context: Context,
			_info: GraphQLResolveInfo
		) {
			// In order to determine what type obj actualy is, we test for the
			// existance of fields that are unique to each of the types that obj
			// could be. Example: If obj has things that only comments have,
			// then obj is a comment. We also use type assertions to double
			// check that each of these tests are correct. See Flow's docs on
			// "type refinement" for more _info.
			if ((<dataModel.Comment>obj)._id) {
				return "Comment";
			}

			if ((<dataModel.Review>obj).reviewId) {
				return "Review";
			}

			// It should be imposible to get here.
			// TODO throw a more informative error message.
			return null;
		},
	},

	Comment: {
		// WARNING: Comments have not been fully implemented yet. The code for
		// them is a half done mess. Keep that in mind when working with it.
		...CommentResolvers.defaultResolvers,

		id: (obj, _args, _context, _info) =>
			dataModel.commentIdToString(obj._id),

		// Dates do not work with graphqlgen yet. It does not understand custom
		// scalers and thus it thinks that dates need to be resolved to strings.
		created: (obj, _args, _context, _info) => obj.datePosted,

		author: (obj, _args, _context, _info) =>
			dataModel.getAuthorOfComment(obj),

		parent: (obj, _args, _context, _info) =>
			dataModel.getParentOfComment(obj),

		children: (obj, args, _context, _info) =>
			dataModel.getCommentsByParent(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		votes: (obj, args, _context, _info) =>
			dataModel.getVotesBySubject(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),
	},

	Company: {
		...CompanyResolvers.defaultResolvers,

		id: (obj, _args, _context, _info) =>
			dataModel.companyIdToString(obj.companyId),
		name: (obj, _args, _context, _info) => obj.name,

		locations: (obj, _args, _context, _info) =>
			dataModel.getLocationsByCompany(obj),
		// Dates do not work with graphqlgen yet. It does not understand custom
		// scalers and thus it thinks that dates need to be resolved to strings.
		dateJoined: (obj, _args, _context, _info) => obj.dateAdded,

		avgStarRatings: (obj, _args, _context, _info) => {
			if (
				obj.healthAndSafety === null ||
				obj.healthAndSafety === undefined ||
				obj.managerRelationship === null ||
				obj.managerRelationship === undefined ||
				obj.workEnvironment === null ||
				obj.workEnvironment === undefined ||
				obj.benefits === null ||
				obj.benefits === undefined ||
				obj.overallSatisfaction === null ||
				obj.overallSatisfaction === undefined
			) {
				return null;
			} else {
				return {
					healthAndSafety: obj.healthAndSafety,
					managerRelationship: obj.managerRelationship,
					workEnvironment: obj.workEnvironment,
					benefits: obj.benefits,
					overallSatisfaction: obj.overallSatisfaction,
				};
			}
		},

		reviews: (obj, args, _context, _info) =>
			dataModel.getReviewsByCompany(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		jobAds: (obj, args, _context, _info) =>
			dataModel.getJobAdsByCompany(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		numJobAds: (obj, _args, _context, _info) =>
			dataModel.countJobAdsByCompany(obj),
		salaries: (obj, args, _context, _info) =>
			dataModel.getSalariesByCompany(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		numSalaries: (obj, _args, _context, _info) =>
			dataModel.countSalariesByCompany(obj),
	},

	JobAd: {
		...JobAdResolvers.defaultResolvers,

		id: (obj, _args, _context, _info) =>
			dataModel.jobAdIdToString(obj.jobadId),

		locations: (obj, _args, _context, _info) =>
			dataModel.getLocationsByJobAd(obj),

		// Dates do not work with graphqlgen yet. It does not understand custom
		// scalers and thus it thinks that dates need to be resolved to strings.
		created: (obj, _args, _context, _info) => obj.dateAdded,

		company: (obj, _args, _context, _info) =>
			dataModel.getCompanyOfJobAd(obj),
	},

	Review: {
		...ReviewResolvers.defaultResolvers,

		id: (obj, _args, _context, _info) =>
			dataModel.reviewIdToString(obj.reviewId),

		location: (obj, _args, _context, _info) =>
			dataModel.parseLocationString(obj.location),
		wouldRecommendToOtherJobSeekers: (obj, _args, _context, _info) =>
			obj.wouldRecommend,

		starRatings: (obj, _args, _context, _info) => ({
			healthAndSafety: obj.healthAndSafety,
			managerRelationship: obj.managerRelationship,
			workEnvironment: obj.workEnvironment,
			benefits: obj.benefits,
			overallSatisfaction: obj.overallSatisfaction,
		}),

		// Dates do not work with graphqlgen yet. It does not understand custom
		// scalers and thus it thinks that dates need to be resolved to strings.
		created: (obj, _args, _context, _info) => obj.dateAdded,

		author: (obj, _args, _context, _info) =>
			dataModel.getAuthorOfReview(obj),

		company: (obj, _args, _context, _info) =>
			dataModel.getCompanyOfReview(obj),

		comments: (obj, args, _context, _info) =>
			dataModel.getCommentsByParent(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		votes: (obj, args, _context, _info) =>
			dataModel.getVotesBySubject(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		currentUserVote: (obj, _args, context, _info) =>
			context.user
				? dataModel.getVoteByAuthorAndSubject(context.user, obj)
				: null,
	},

	Salary: {
		...SalaryResolvers.defaultResolvers,

		id: (obj, _args, _context, _info) =>
			dataModel.salaryIdToString(obj.salaryid),

		jobTitle: (obj, _args, _context, _info) => obj.jobtitle,
		location: (obj, _args, _context, _info) =>
			dataModel.parseLocationString(obj.salarylocation),
		incomeType: (obj, _args, _context, _info) => obj.incometype,
		incomeAmount: (obj, _args, _context, _info) => obj.incomeamount,

		// Dates do not work with graphqlgen yet. It does not understand custom
		// scalers and thus it thinks that dates need to be resolved to strings.
		created: (obj, _args, _context, _info) => obj.dateadded,

		author: (obj, _args, _context, _info) =>
			dataModel.getAuthorOfSalary(obj),

		company: (obj, _args, _context, _info) =>
			dataModel.getCompanyOfSalary(obj),
	},

	User: {
		...UserResolvers.defaultResolvers,

		id: (obj, _args, _context, _info) => dataModel.userIdToString(obj._id),

		role: (obj, _args, _context, _info) => {
			if (obj.role === "worker") return "WORKER";
			if (obj.role === "company-unverified") return "COMPANY_UNVERIFIED";
			if (obj.role === "company") return "COMPANY";
			throw Error("User role is not valid.");
		},

		// Dates do not work with graphqlgen yet. It does not understand custom
		// scalers and thus it thinks that dates need to be resolved to strings.
		created: (obj, _args, _context, _info) => obj.createdAt,

		company: (obj, _args, _context, _info) =>
			dataModel.getCompanyOfUser(obj),

		reviews: (obj, args, _context, _info) =>
			dataModel.getReviewsByAuthor(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		comments: (obj, args, _context, _info) =>
			dataModel.getCommentsByAuthor(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),

		votes: (obj, args, _context, _info) =>
			dataModel.getVotesByAuthor(
				obj,
				args.pageNum || 0,
				args.pageSize || defaultPageSize
			),
	},

	VoteSubject: {
		__resolveType(
			obj: dataModel.VoteSubject,
			_context: Context,
			_info: GraphQLResolveInfo
		) {
			// In order to determine what type obj actualy is, we test for the
			// existance of fields that are unique to each of the types that obj
			// could be. Example: If obj has things that only comments have,
			// then obj is a comment. We also use type assertions to double
			// check that each of these tests are correct. See Flow's docs on
			// "type refinement" for more _info.
			if ((<dataModel.Comment>obj)._id) {
				return "Comment";
			}

			if ((<dataModel.Review>obj).reviewId) {
				return "Review";
			}

			// It should be imposible to get here.
			// TODO throw a more informative error message.
			return null;
		},
	},

	Vote: {
		...VoteResolvers.defaultResolvers,

		id: (obj, _args, _context, _info) =>
			dataModel.voteIdToString(dataModel.getIdOfVote(obj)),
		isUpvote: (obj, _args, _context, _info) => obj.isUpvote,

		author: (obj, _args, _context, _info) => dataModel.getAuthorOfVote(obj),

		subject: (obj, _args, _context, _info) =>
			dataModel.getSubjectOfVote(obj),
	},

	Location: {
		...LocationResolvers.defaultResolvers,
	},

	StarRatings: {
		...StarRatingsResolvers.defaultResolvers,
	},

	DateTime: GraphQLDateTime,
};

export default resolvers;
